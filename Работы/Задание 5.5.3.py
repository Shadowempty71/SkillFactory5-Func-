#Напишите декоратор, который будет сохранять результаты выполнения
# декорируемой функции в словаре. Словарь должен находиться в nonlocal области
# в следующем формате: по ключу располагается аргумент функции,
# по значению — результат работы функции, например, {n: f(n)}.

# И при повторном вызове функции декоратор будет брать значение из словаря,
# а не вычислять заново. То есть словарь можно считать промежуточной памятью
# на время работы программы, где будут храниться ранее вычисленные значения.
# Исходная функция, которую нужно задекорировать имеет следующий вид
# и выполняет простое умножение на число 123456789:
def decorator(func):
    library = {}
    def wrapper(num):
        nonlocal library
        if num not in library:
            library[num] = func(num)
            print(f"Добавление результата в кэш: {library[num]}")
        else:
            print(f"Возвращение результата из кэша: {library[num]}")
        print(f"Кэш {library}")
        return library[num]
    return wrapper
@decorator
def f(n):
    return n * 123456789
f(15)
f(15)




